DOCUMENTO ESCRITO – PROYECTO FINAL
Desarrollo de Software I – 2025
Grupo 5

Integrantes:
 Thomas Alzate Arteaga
 Jacobo Gelacio Guevara

Videojuego desarrollado: 
Orden Correcto

1. Introducción
El videojuego “Orden Correcto” es una aplicación de consola en C++ diseñada para evaluar la capacidad del jugador de ordenar secuencias numéricas en orden descendente. A diferencia de implementaciones tradicionales, en esta versión el usuario no ingresa los números directamente, sino que introduce los índices (posiciones) correspondientes al orden correcto.

Por ejemplo, dada la lista:
1. 4 2. 9 3. 2 4. 7 5. 1 6. 5,
el orden descendente correcto es: 9 (índice 2), 7 (índice 4), 5 (índice 6), 4 (índice 1), 2 (índice 3), 1 (índice 5).
Por tanto, la respuesta esperada es: 2, 4, 6, 1, 3, 5.

El juego está compuesto por 6 niveles, cada uno con una secuencia diferente, y otorga un máximo de 6 puntos por nivel (36 en total). Además, incluye un menú interactivo con cuatro opciones:

Jugar
Reglas
Puntajes
Salir
Esta versión fue mejorada bajo la retroalimentación directa de un docente del curso, quien nos sugirió ampliar la funcionalidad del proyecto original, específicamente:

Incorporar un contador de tiempo que mida la duración de cada partida.
Implementar un registro de hasta 10 jugadores, almacenando sus puntajes y tiempos para consulta posterior.
Dichas mejoras transformaron un ejercicio básico en un sistema más completo, con elementos de persistencia temporal y evaluación comparativa.

2. Problemas presentados
Durante el desarrollo del proyecto, enfrentamos múltiples desafíos técnicos y conceptuales, que abordamos principalmente mediante el método de prueba y error, complementado con investigación autodidacta y asesoría docente.

Problemas resueltos mediante prueba y error
Implementación del contador de tiempo:
Inicialmente, intentamos usar clock() de <ctime>, pero descubrimos que no era lo suficientemente preciso para medir tiempos cortos de interacción en consola. Tras varias pruebas, validamos que gettimeofday() (de <sys/time.h>) ofrecía una resolución de microsegundos ideal.
→ Solución: Diseñamos la función time_diff() para calcular la diferencia en segundos con precisión decimal.
Almacenamiento de jugadores y puntajes:
En un primer intento, usamos un solo entero para guardar el último puntaje, lo que impedía llevar un historial. Mediante prueba y error, probamos distintas estructuras hasta decidir usar dos arreglos paralelos:
players[10]: almacena los puntajes (máximo 10 jugadores, según indicación docente).
time[10]: almacena los tiempos correspondientes.
→ Clave: usamos un contador global i para llevar el índice del siguiente jugador.
Menú de puntajes no actualizado:
Al principio, al mostrar los puntajes, el programa mostraba basura en posiciones vacías. Corregimos esto iterando solo hasta i (número de jugadores reales), no hasta el tamaño total del arreglo.
Problemas no resueltos
Reglas incorrectas en el menú:
El texto de las reglas aún dice: “orden ascendente”, cuando el juego claramente requiere orden descendente. Este error persiste por una copia sin revisión del código anterior.
→ Impacto: puede generar confusión en usuarios nuevos.
Falta de validación de entradas en los niveles:
El programa no verifica que los índices ingresados estén entre 1 y 6 ni que no se repitan. Un jugador podría ingresar 0, 7, 99 y el sistema lo aceptaría sin advertencia.
→ Razón: por limitaciones de tiempo y alcance del curso, no se implementó validación completa.
Límite fijo de 10 jugadores sin reinicio:
Tras 10 jugadores, el programa no permite nuevos registros. No se implementó un sistema cíclico ni de archivo para extenderlo.

3. Desarrollo del proyecto
Mejoras sugeridas por el docente
Durante una revisión intermedia, un docente del curso nos recomendó explícitamente enriquecer el proyecto con:

Contador de tiempo real por partida.
Registro de hasta 10 jugadores con sus respectivos puntajes y tiempos.
Estas indicaciones fueron clave para elevar la complejidad del proyecto y alinearlo con estándares de evaluación más altos.
Herramientas y librerías utilizadas
Lenguaje: C++ (estándar básico, compatible con g++ y compiladores comunes).
Librerías:
<iostream>: entrada/salida estándar (cin, cout).
<locale.h>: soporte para caracteres acentuados mediante setlocale(LC_ALL, "").
<sys/time.h> y <ctime>: medición precisa del tiempo con gettimeofday().
Funciones del sistema:
system("cls") y system("pause"): mejora de experiencia en consola (solo Windows).
Estructuras de programación aplicadas
Arreglos:
R1[6] a R6[6]: respuestas por nivel (índices del 1 al 6).
players[10] y time[10]: historial de hasta 10 jugadores.
Ciclos:
for: para solicitar respuestas (6 por nivel) y listar puntajes.
while: validación del menú (opciones 1–4) y bucle principal.
Estructuras de control:
switch: gestión del menú.
if: evaluación posición por posición de las respuestas.
Función personalizada:
float time_diff(struct timeval *start, struct timeval *end): cálculo de tiempo en segundos.
Metodología de trabajo en equipo
Trabajamos bajo un modelo de retroalimentación continua: codificábamos en parejas, uno escribía mientras el otro probaba y documentaba.
Usamos el método de prueba y error como estrategia central: implementábamos una idea, la probábamos, analizábamos los resultados y ajustábamos.
Incorporamos feedback docente como parte del ciclo de mejora, lo que nos permitió redirigir el enfoque del proyecto en una etapa temprana.
Utilización de Inteligencia Artificial
La IA fue una herramienta de apoyo pedagógico, no un generador automático de soluciones. Su uso incluyó:

Explicación de gettimeofday():
-Nos ayudó a comprender cómo usar esta función y cómo convertir microsegundos a segundos de forma legible.

Corrección de lógica de índices:
Verificamos con IA las secuencias correctas de índices para cada nivel, evitando errores en las claves de evaluación.

Detección de inconsistencias:
La IA nos alertó sobre la contradicción entre las reglas (“ascendente”) y la lógica real del juego (“descendente”).

Redacción del documento:
Nos asistió en estructurar el informe con claridad, coherencia y lenguaje técnico adecuado.

Ética del uso:
No copiamos código. Cada línea fue escrita, probada y entendida por nosotros. La IA fue un tutor virtual que respondía preguntas, no un sustituto del pensamiento crítico. 

Beneficios del uso de IA:

-Reducción del tiempo de investigación técnica.
-Refuerzo conceptual inmediato.
-Mayor precisión en la documentación.
-Mejor preparación para la defensa oral.

4. Conclusiones
El desarrollo de “Orden Correcto” superó nuestras expectativas iniciales, especialmente gracias a la retroalimentación docente y al enfoque iterativo basado en prueba y error.
Aprendimos que el software no se construye de forma lineal, sino mediante ciclos constantes de implementación, fallo, análisis y mejora.

Los aprendizajes más significativos fueron:

-Cómo medir el tiempo de ejecución con precisión en C++.
-Cómo diseñar un sistema de historial simple usando arreglos paralelos.
-La importancia de validar no solo el código, sino también la experiencia del usuario (como el error en las reglas).
-La IA fue un aliado estratégico que potenció nuestra autonomía como aprendices, permitiéndonos concentrarnos en la lógica y no en la memorización de sintaxis.

Aspectos a mejorar en futuras versiones:
-Corregir las reglas del juego.
-Validar que los índices ingresados estén entre 1 y 6 y no se repitan.
-Reemplazar los arreglos estáticos por archivos o estructuras dinámicas.
-Hacer el código multiplataforma (evitar system("cls")).
En conclusión, entregamos un proyecto que demuestra dominio competente de las estructuras vistas en clase, uso ético y efectivo de IA, y capacidad de innovación bajo guía docente. Estamos orgullosos del resultado y de lo que aprendimos en el proceso.

